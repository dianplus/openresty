name: Auto ARM64 Build with Spot Instance

on:
  push:
    branches:
      - develop
      - master
    tags:
      - 'v*'
  workflow_dispatch:
    inputs:
      image_tag:
        description: 'Custom image tag'
        required: false
        default: ''

env:
  ALIYUN_REGION: cn-hangzhou
  # ARM64 supported availability zones (sorted by priority, based on actual testing confirmed zones)
  ARM64_ZONES: cn-hangzhou-j,cn-hangzhou-k,cn-hangzhou-b
  RUNNER_NAME: openresty-arm64-spot

jobs:
  create-spot-runner:
    runs-on: ubuntu-latest
    permissions:
      actions: write
      contents: read
      id-token: write
    outputs:
      instance_id: ${{ steps.create.outputs.instance_id }}
      runner_name: ${{ steps.create.outputs.runner_name }}
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4

      - name: Configure Aliyun CLI
        run: |
          wget https://aliyuncli.alicdn.com/aliyun-cli-linux-latest-amd64.tgz
          tar -xzf aliyun-cli-linux-latest-amd64.tgz
          sudo mv aliyun /usr/local/bin/
          
          aliyun configure set \
            --profile default \
            --mode AK \
            --region ${{ env.ALIYUN_REGION }} \
            --access-key-id ${{ secrets.ALIYUN_ACCESS_KEY_ID }} \
            --access-key-secret ${{ secrets.ALIYUN_ACCESS_KEY_SECRET }}

      - name: Download Spot Instance Advisor
        run: |
          wget https://github.com/maskshell/spot-instance-advisor/releases/download/v1.0.0/spot-instance-advisor-linux-amd64
          chmod +x spot-instance-advisor-linux-amd64
          sudo mv spot-instance-advisor-linux-amd64 /usr/local/bin/spot-instance-advisor

      - name: Find Cheapest Instance Type
        id: find_cheapest
        run: |
          # Query all ARM64 instance type prices (8c16g to 64c128g)
          echo "Querying all ARM64 instance type prices..."
          ALL_PRICES=$(spot-instance-advisor \
            -accessKeyId="${{ secrets.ALIYUN_ACCESS_KEY_ID }}" \
            -accessKeySecret="${{ secrets.ALIYUN_ACCESS_KEY_SECRET }}" \
            -region=cn-hangzhou \
            -family="ecs.c8y,ecs.c8r" \
            -mincpu=8 -maxcpu=8 -minmem=16 -maxmem=16 \
            -resolution=7 -limit=20 --json)
          
          # Select instance with lowest price per core
          CHEAPEST_INSTANCE=$(echo "$ALL_PRICES" | jq -r 'min_by(.pricePerCore) | .instanceTypeId')
          CHEAPEST_PRICE_PER_CORE=$(echo "$ALL_PRICES" | jq -r 'min_by(.pricePerCore) | .pricePerCore')
          CHEAPEST_ZONE=$(echo "$ALL_PRICES" | jq -r 'min_by(.pricePerCore) | .zoneId')
          
          # Extract CPU cores from instance type name
          # ecs.c8y.8xlarge = 32 cores, ecs.c8y.4xlarge = 16 cores, ecs.c8y.2xlarge = 8 cores
          if [[ "$CHEAPEST_INSTANCE" =~ \.8xlarge$ ]]; then
            CPU_CORES=32
          elif [[ "$CHEAPEST_INSTANCE" =~ \.4xlarge$ ]]; then
            CPU_CORES=16
          elif [[ "$CHEAPEST_INSTANCE" =~ \.2xlarge$ ]]; then
            CPU_CORES=8
          elif [[ "$CHEAPEST_INSTANCE" =~ \.xlarge$ ]]; then
            CPU_CORES=4
          elif [[ "$CHEAPEST_INSTANCE" =~ \.large$ ]]; then
            CPU_CORES=2
          else
            # Default fallback
            CPU_CORES=8
          fi
          
          # Calculate total price: price per core × CPU cores
          TOTAL_PRICE=$(echo "$CHEAPEST_PRICE_PER_CORE * $CPU_CORES" | bc -l)
          
          # Set spot price limit to 120% of total price
          SPOT_PRICE_LIMIT=$(echo "$TOTAL_PRICE * 1.2" | bc -l)
          
          echo "Cheapest instance type: $CHEAPEST_INSTANCE"
          echo "Price per core: $CHEAPEST_PRICE_PER_CORE"
          echo "CPU cores: $CPU_CORES"
          echo "Total price: $TOTAL_PRICE"
          echo "Availability zone: $CHEAPEST_ZONE"
          echo "Spot price limit: $SPOT_PRICE_LIMIT"
          
          echo "cheapest_instance=$CHEAPEST_INSTANCE" >> $GITHUB_OUTPUT
          echo "cheapest_zone=$CHEAPEST_ZONE" >> $GITHUB_OUTPUT
          echo "spot_price_limit=$SPOT_PRICE_LIMIT" >> $GITHUB_OUTPUT

      - name: Create Spot Instance
        id: create
        run: |
          RUNNER_NAME="${{ env.RUNNER_NAME }}-$(date +%s)"
          
          # Create user data script
          cat > user_data.sh << 'EOF'
          #!/bin/bash
          set -e
          
          # Configure proxy from GitHub environment variables
          if [ -n "$HTTP_PROXY" ]; then
            echo "Setting HTTP_PROXY: $HTTP_PROXY"
            export HTTP_PROXY="$HTTP_PROXY"
            echo "export HTTP_PROXY=\"$HTTP_PROXY\"" >> /etc/environment
          fi
          
          if [ -n "$HTTPS_PROXY" ]; then
            echo "Setting HTTPS_PROXY: $HTTPS_PROXY"
            export HTTPS_PROXY="$HTTPS_PROXY"
            echo "export HTTPS_PROXY=\"$HTTPS_PROXY\"" >> /etc/environment
          fi
          
          # Set NO_PROXY with default values if not provided
          if [ -n "$NO_PROXY" ]; then
            echo "Setting NO_PROXY: $NO_PROXY"
            export NO_PROXY="$NO_PROXY"
            echo "export NO_PROXY=\"$NO_PROXY\"" >> /etc/environment
          else
            NO_PROXY_DEFAULT="localhost,127.0.0.1,::1,192.168.0.0/16,10.0.0.0/8,172.16.0.0/12,mirrors.tuna.tsinghua.edu.cn,mirrors.aliyun.com,.aliyun.com,.aliyuncs.com,.alicdn.com,.dianplus.cn,.dianjia.io,.taobao.com"
            echo "Setting NO_PROXY default: $NO_PROXY_DEFAULT"
            export NO_PROXY="$NO_PROXY_DEFAULT"
            echo "export NO_PROXY=\"$NO_PROXY_DEFAULT\"" >> /etc/environment
          fi
          
          # Update system
          yum update -y
          
          # Install necessary software
          yum install -y docker git curl wget jq
          systemctl start docker
          systemctl enable docker
          
          # Download GitHub Actions Runner
          cd /root
          echo \"=== Starting GitHub Actions Runner Download ===\"
          
          # Get latest version
          echo \"Querying latest runner version...\"
          RUNNER_VERSION=\"2.329.0\"  # Default fallback version
          echo \"Fetching latest version from GitHub API...\"
          curl -s --proxy \"$HTTP_PROXY\" https://api.github.com/repos/actions/runner/releases/latest > api_response.json
          echo \"API response saved to api_response.json\"
          echo \"Checking if jq is available...\"
          which jq || echo \"jq not found, installing...\"
          yum install -y jq
          TAG_NAME=\`jq -r .tag_name api_response.json\`
          echo \"TAG_NAME: $TAG_NAME\"
          if [ \"$TAG_NAME\" != \"null\" ] && [ -n \"$TAG_NAME\" ]; then
            RUNNER_VERSION=\`echo \"$TAG_NAME\" | sed \"s/^v//\"\`
            echo \"RUNNER_VERSION after processing: $RUNNER_VERSION\"
          else
            echo \"Failed to get version from API, using default: $RUNNER_VERSION\"
          fi
          echo \"Latest version: $RUNNER_VERSION\"
          
          # Validate version query
          if [ -z \"$RUNNER_VERSION\" ] || [ \"$RUNNER_VERSION\" = \"null\" ]; then
            echo \"❌ Failed to get runner version from GitHub API\"
            echo \"API Response content:\"
            cat api_response.json
            echo \"Using fallback version: 2.329.0\"
            RUNNER_VERSION=\"2.329.0\"
          fi
          
          # Clean version string (remove any whitespace or special characters)
          if [ -n \"$RUNNER_VERSION\" ]; then
            RUNNER_VERSION=\`echo \"$RUNNER_VERSION\" | tr -d '[:space:]'\`
            echo \"Cleaned version: $RUNNER_VERSION\"
          else
            echo \"❌ RUNNER_VERSION is empty, cannot clean\"
            exit 1
          fi
          
          ARCH=arm64
          FILE=actions-runner-linux-$ARCH-$RUNNER_VERSION.tar.gz
          URL=https://github.com/actions/runner/releases/download/v$RUNNER_VERSION/$FILE
          echo \"Downloading GitHub Actions Runner $RUNNER_VERSION $ARCH...\"
          echo \"URL: $URL\"
          echo \"FILE: $FILE\"
          
          # Download with error handling
          if ! curl -fL --proxy \"\$HTTP_PROXY\" -o \"\$FILE\" \"\$URL\"; then
            echo \"❌ Failed to download runner from \$URL\"
            exit 1
          fi
          
          # Verify download
          if [ ! -f \"\$FILE\" ] || [ ! -s \"\$FILE\" ]; then
            echo \"❌ Downloaded file is missing or empty\"
            exit 1
          fi
          
          du -h \$FILE > file_size.txt
          FILE_SIZE=\`cut -f1 file_size.txt\`
          echo \"✅ Successfully downloaded \$FILE - \$FILE_SIZE\"
          
          # Extract and verify
          echo \"Extracting runner files...\"
          if ! tar xzf \"\$FILE\"; then
            echo \"❌ Failed to extract runner archive\"
            exit 1
          fi
          
          # Verify essential files exist
          if [ ! -f \"config.sh\" ] || [ ! -f \"run.sh\" ]; then
            echo \"❌ Essential runner files missing after extraction\"
            exit 1
          fi
          
          echo \"✅ Runner files extracted successfully\"
          rm -f \"\$FILE\"
          
          # Configure runner
          echo \"=== Configuring GitHub Actions Runner ===\"
          echo \"Configuring runner with proxy settings...\"
          echo \"HTTP_PROXY: \$HTTP_PROXY\"
          echo \"HTTPS_PROXY: \$HTTPS_PROXY\"
          echo \"NO_PROXY: \$NO_PROXY\"
          
          # Configure with error handling
          if ! ./config.sh --url https://github.com/dianplus/openresty --token \$GITHUB_TOKEN --name \$RUNNER_NAME --labels self-hosted,linux,ARM64 --unattended --replace; then
            echo \"❌ Failed to configure runner\"
            exit 1
          fi
          
          echo \"✅ Runner configured successfully\"
          
          # Start runner
          echo \"=== Starting GitHub Actions Runner ===\"
          nohup ./run.sh > runner.log 2>&1 &
          RUNNER_PID=\$!
          echo \"Runner started with PID: \$RUNNER_PID\"
          
          # Wait a moment and check if runner is still running
          sleep 5
          if ! kill -0 \$RUNNER_PID 2>/dev/null; then
            echo \"❌ Runner process died immediately\"
            echo \"Runner log:\"
            cat runner.log
            exit 1
          fi
          
          echo \"✅ Runner is running successfully\"
          echo \"=== GitHub Actions Runner Setup Complete ===\"
          
          # Workflow will handle cleanup automatically after build completion
          EOF
          
          # spot-instance-advisor tool has completed instance type query and price comparison
          echo "Using dynamically selected instance type and price..."
          
          # Use dynamically selected instance type and price
          BEST_TYPE="${{ steps.find_cheapest.outputs.cheapest_instance }}"
          BEST_ZONE="${{ steps.find_cheapest.outputs.cheapest_zone }}"
          MAX_PRICE="${{ steps.find_cheapest.outputs.spot_price_limit }}"
          
          echo "Using dynamically selected instance type: $BEST_TYPE"
          echo "Recommended availability zone: $BEST_ZONE"
          echo "Spot price limit: $MAX_PRICE"
          
          # Dynamically get list of zones supporting BEST_TYPE, prioritize advisor recommended zone
          echo "Querying zones supporting instance type $BEST_TYPE..."
          RAW_ZONES=$(aliyun ecs DescribeAvailableResource \
            --RegionId ${{ env.ALIYUN_REGION }} \
            --DestinationResource InstanceType)
          
          # Check if the command succeeded
          if [ $? -ne 0 ] || [ -z "$RAW_ZONES" ]; then
            echo "Warning: Failed to query available resources, using preset zones"
            DYNAMIC_ZONES=""
          else
            echo "Successfully queried available resources"
            DYNAMIC_ZONES=$(echo "$RAW_ZONES" | jq -r \
              --arg TYPE "$BEST_TYPE" \
              '.AvailableZones.AvailableZone[] | select(.AvailableResources.AvailableResource[].SupportedResources.SupportedResource[] | select(.Value==$TYPE and (.Status=="Available" or .Status=="WithStock"))) | .ZoneId' | sort -u | tr '\n' ' ')
          fi

          # Combine recommended zone with dynamically queried zones
          if [ -n "$BEST_ZONE" ] && [ -n "$DYNAMIC_ZONES" ]; then
            # Check if recommended zone is in the supported zones
            if echo "$DYNAMIC_ZONES" | grep -q "$BEST_ZONE"; then
              ZONES="$BEST_ZONE $DYNAMIC_ZONES"
            else
              echo "Warning: Recommended zone $BEST_ZONE not supported for $BEST_TYPE, using dynamic zones only"
              ZONES="$DYNAMIC_ZONES"
            fi
          elif [ -n "$DYNAMIC_ZONES" ]; then
            ZONES="$DYNAMIC_ZONES"
          else
            echo "Warning: No dynamic zones found, using preset zones"
            ZONES="${{ env.ARM64_ZONES }}"
          fi
          INSTANCE_ID=""
          SELECTED_ZONE=""
          
          for ZONE in $(echo $ZONES | tr ',' ' ' | xargs -n1 | sort -u); do
            echo "Attempting to create ARM64 instance in zone $ZONE..."
            
            # Select VSwitch based on zone with intelligent fallback
            case $ZONE in
              cn-hangzhou-b)
                VSWITCH_ID="${{ secrets.ALIYUN_VSWITCH_ID_B }}"
                ;;
              cn-hangzhou-g)
                VSWITCH_ID="${{ secrets.ALIYUN_VSWITCH_ID_G }}"
                ;;
              cn-hangzhou-h)
                VSWITCH_ID="${{ secrets.ALIYUN_VSWITCH_ID_H }}"
                ;;
              cn-hangzhou-i)
                VSWITCH_ID="${{ secrets.ALIYUN_VSWITCH_ID_I }}"
                ;;
              cn-hangzhou-j)
                VSWITCH_ID="${{ secrets.ALIYUN_VSWITCH_ID_J }}"
                ;;
              cn-hangzhou-k)
                VSWITCH_ID="${{ secrets.ALIYUN_VSWITCH_ID_K }}"
                ;;
              *)
                VSWITCH_ID="${{ secrets.ALIYUN_VSWITCH_ID }}"
                ;;
            esac
            
            # If no zone-specific VSwitch configured, try to find one dynamically
            if [ -z "$VSWITCH_ID" ]; then
              echo "No zone-specific VSwitch configured for $ZONE, searching for available VSwitch..."
              
              # Query available VSwitches in the zone
              AVAILABLE_VSWITCHES=$(aliyun vpc DescribeVSwitches \
                --RegionId ${{ env.ALIYUN_REGION }} \
                --ZoneId $ZONE \
                --VpcId ${{ secrets.ALIYUN_VPC_ID }} \
                --output json | jq -r '.VSwitches.VSwitch[] | select(.Status=="Available") | .VSwitchId' | head -1)
              
              if [ -n "$AVAILABLE_VSWITCHES" ]; then
                VSWITCH_ID="$AVAILABLE_VSWITCHES"
                echo "Found available VSwitch: $VSWITCH_ID in zone $ZONE"
              else
                echo "Warning: No available VSwitch found in zone $ZONE, using default VSwitch"
                VSWITCH_ID="${{ secrets.ALIYUN_VSWITCH_ID }}"
              fi
            fi
            
            # Create ECS instance (using optimal instance type)
            echo "Creating instance with parameters:"
            echo "  Zone: $ZONE"
            echo "  VSwitch: $VSWITCH_ID"
            echo "  Instance Type: $BEST_TYPE"
            echo "  Spot Price Limit: $MAX_PRICE"
            
            RESULT=$(aliyun ecs RunInstances \
              --RegionId ${{ env.ALIYUN_REGION }} \
              --ZoneId $ZONE \
              --ImageId ${{ secrets.ALIYUN_ARM64_IMAGE_ID }} \
              --InstanceType $BEST_TYPE \
              --InstanceName $RUNNER_NAME \
              --SecurityGroupId ${{ secrets.ALIYUN_SECURITY_GROUP_ID }} \
              --VSwitchId $VSWITCH_ID \
              --UserData $(base64 -w 0 user_data.sh) \
              --KeyPairName ${{ secrets.ALIYUN_KEY_PAIR_NAME }} \
              --SpotStrategy SpotWithPriceLimit \
              --SpotPriceLimit $MAX_PRICE \
              --SystemDisk.Category cloud_essd \
              --SystemDisk.Size 40)
            
            EXIT_CODE=$?
            if [ $EXIT_CODE -eq 0 ] && [ -n "$RESULT" ]; then
              INSTANCE_ID=$(echo $RESULT | jq -r '.InstanceIdSets.InstanceIdSet[0]')
              if [ "$INSTANCE_ID" != "null" ] && [ -n "$INSTANCE_ID" ]; then
                SELECTED_ZONE=$ZONE
                echo "Successfully created instance in zone $ZONE: $INSTANCE_ID"
                break
              fi
            fi
            
            echo "Failed to create instance in zone $ZONE (exit code: $EXIT_CODE)"
            if [ -n "$RESULT" ]; then
              echo "Error details: $RESULT"
            fi
            echo "Trying next zone..."
            sleep 2
          done
          
          if [ -z "$INSTANCE_ID" ] || [ "$INSTANCE_ID" = "null" ]; then
            echo "Unable to create ARM64 instance in any zone, please check configuration"
            exit 1
          fi
          
          echo "instance_id=$INSTANCE_ID" >> $GITHUB_OUTPUT
          echo "runner_name=$RUNNER_NAME" >> $GITHUB_OUTPUT
          echo "selected_zone=$SELECTED_ZONE" >> $GITHUB_OUTPUT
          echo "instance_type=$BEST_TYPE" >> $GITHUB_OUTPUT
          echo "max_price=$MAX_PRICE" >> $GITHUB_OUTPUT
          echo "Created instance: $INSTANCE_ID in zone: $SELECTED_ZONE with type: $BEST_TYPE"

      - name: Wait for Runner Registration
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          echo "Waiting for runner to register..."
          sleep 120
          
          # Check runner status using GitHub API directly
          RUNNER_REGISTERED=false
          for i in {1..3}; do
            echo "⏳ Checking runner status... ($i/3)"
            
            # Use GitHub API directly instead of gh command
            echo "🔍 Querying GitHub API for runner status..."
            API_RESPONSE=$(curl -s --max-time 10 --connect-timeout 5 -H "Authorization: token ${{ secrets.GITHUB_TOKEN }}" \
              -H "Accept: application/vnd.github.v3+json" \
              "https://api.github.com/repos/dianplus/openresty/actions/runners" 2>&1)
            
            # Check if API response is valid
            CURL_EXIT_CODE=$?
            if [ $CURL_EXIT_CODE -ne 0 ] || [ -z "$API_RESPONSE" ]; then
              echo "⚠️ API request failed (exit code: $CURL_EXIT_CODE) or returned empty response"
              RUNNER_STATUS="api_error"
            else
              # Check for permission errors first
              if echo "$API_RESPONSE" | jq -e '.message' > /dev/null 2>&1; then
                ERROR_MESSAGE=$(echo "$API_RESPONSE" | jq -r '.message')
                if [ "$ERROR_MESSAGE" = "Resource not accessible by integration" ]; then
                  echo "❌ GitHub token lacks required permissions for actions/runners API"
                  echo "Required permissions: actions:write, contents:read"
                  RUNNER_STATUS="permission_denied"
                else
                  echo "⚠️ API error: $ERROR_MESSAGE"
                  RUNNER_STATUS="api_error"
                fi
              # Check if response contains runners array
              elif echo "$API_RESPONSE" | jq -e '.runners' > /dev/null 2>&1; then
                RUNNER_STATUS=$(echo "$API_RESPONSE" | jq -r ".runners[] | select(.name==\"${{ steps.create.outputs.runner_name }}\") | .status // empty")
                if [ -z "$RUNNER_STATUS" ]; then
                  RUNNER_STATUS="not_found"
                fi
              else
                echo "⚠️ Invalid API response format"
                echo "API Response: $API_RESPONSE"
                RUNNER_STATUS="invalid_response"
              fi
            fi
            
            if [ "$RUNNER_STATUS" = "online" ]; then
              echo "✅ Runner registered successfully!"
              RUNNER_REGISTERED=true
              break
            elif [ "$RUNNER_STATUS" = "offline" ]; then
              echo "⚠️ Runner found but offline: $RUNNER_STATUS"
            elif [ "$RUNNER_STATUS" = "permission_denied" ]; then
              echo "❌ Cannot check runner status due to insufficient permissions"
              echo "Please update workflow permissions or use a token with actions:write access"
              exit 1
            elif [ "$RUNNER_STATUS" = "api_error" ]; then
              echo "⚠️ API request failed, retrying..."
            elif [ "$RUNNER_STATUS" = "invalid_response" ]; then
              echo "⚠️ Invalid API response, retrying..."
            elif [ "$RUNNER_STATUS" = "not_found" ]; then
              echo "⏳ Runner not found yet, retrying..."
            else
              echo "⏳ Unknown status: $RUNNER_STATUS, retrying..."
            fi
            
            sleep 10
          done
          
          # Check if runner registration failed
          if [ "$RUNNER_REGISTERED" = "false" ]; then
            echo "❌ Runner registration failed after 3 attempts"
            echo "Available runners:"
            curl -s -H "Authorization: token ${{ secrets.GITHUB_TOKEN }}" \
              -H "Accept: application/vnd.github.v3+json" \
              "https://api.github.com/repos/dianplus/openresty/actions/runners" | \
              jq '.runners[] | {name: .name, status: .status, busy: .busy}'
            exit 1
          fi

  build-arm64:
    needs: create-spot-runner
    runs-on: [self-hosted, linux, ARM64]
    if: always() && needs.create-spot-runner.result == 'success'
    permissions:
      contents: read
      packages: write

    steps:
      - name: Checkout repository
        uses: actions/checkout@v4

      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v3

      - name: Log in to Container Registry
        uses: docker/login-action@v3
        with:
          registry: ghcr.io
          username: ${{ github.actor }}
          password: ${{ secrets.GITHUB_TOKEN }}

      - name: Extract metadata
        id: meta
        uses: docker/metadata-action@v5
        with:
          images: ghcr.io/dianplus/openresty
          tags: |
            type=ref,event=branch,suffix=-arm64
            type=ref,event=tag,suffix=-arm64
            type=sha,prefix={{branch}}-arm64-
            type=raw,value=${{ github.event.inputs.image_tag }},enable={{isTruthy(github.event.inputs.image_tag)}}

      - name: Build Docker image (Native ARM64)
        uses: docker/build-push-action@v5
        with:
          context: .
          platforms: linux/arm64
          push: true
          tags: ${{ steps.meta.outputs.tags }}
          labels: ${{ steps.meta.outputs.labels }}
          cache-from: type=registry,ref=ghcr.io/dianplus/openresty:buildcache-arm64
          cache-to: type=registry,ref=ghcr.io/dianplus/openresty:buildcache-arm64,mode=max
          build-args: |
            RESTY_J=16

      - name: Cleanup ECS Instance
        if: always()
        run: |
          echo "Cleaning up ECS instance: ${{ steps.create_instance.outputs.instance_id }}"
          aliyun ecs DeleteInstance --InstanceId ${{ steps.create_instance.outputs.instance_id }} --Force true
          echo "ECS instance deleted successfully"

      - name: Build summary
        run: |
          echo "## Native ARM64 Build Summary" >> $GITHUB_STEP_SUMMARY
          echo "- **Registry**: ghcr.io" >> $GITHUB_STEP_SUMMARY
          echo "- **Image**: dianplus/openresty" >> $GITHUB_STEP_SUMMARY
          echo "- **Tags**: ${{ steps.meta.outputs.tags }}" >> $GITHUB_STEP_SUMMARY
          echo "- **Platform**: linux/arm64" >> $GITHUB_STEP_SUMMARY
          echo "- **Runner**: ${{ needs.create-spot-runner.outputs.runner_name }}" >> $GITHUB_STEP_SUMMARY
          echo "- **Build Time**: $(date -u +%Y-%m-%dT%H:%M:%SZ)" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "✅ **Native ARM64 build completed!**" >> $GITHUB_STEP_SUMMARY

  cleanup:
    needs: [create-spot-runner, build-arm64]
    runs-on: ubuntu-latest
    if: always()
    steps:
      - name: Configure Aliyun CLI
        run: |
          wget https://aliyuncli.alicdn.com/aliyun-cli-linux-latest-amd64.tgz
          tar -xzf aliyun-cli-linux-latest-amd64.tgz
          sudo mv aliyun /usr/local/bin/
          
          aliyun configure set \
            --profile default \
            --mode AK \
            --region ${{ env.ALIYUN_REGION }} \
            --access-key-id ${{ secrets.ALIYUN_ACCESS_KEY_ID }} \
            --access-key-secret ${{ secrets.ALIYUN_ACCESS_KEY_SECRET }}

      - name: Cleanup Spot Instance
        if: needs.create-spot-runner.outputs.instance_id != ''
        run: |
          echo "Cleaning up instance: ${{ needs.create-spot-runner.outputs.instance_id }}"
          aliyun ecs DeleteInstance --InstanceId ${{ needs.create-spot-runner.outputs.instance_id }} --Force true
          echo "✅ Instance cleaned up successfully"
